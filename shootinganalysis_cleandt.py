# -*- coding: utf-8 -*-
"""ShootingAnalysis_CleanDT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JaSN8Agz9e0YlJNKE4y0D6ICMPlNS_FU
"""

import pandas as pd
import numpy as np
# Import the module for downloading files in Google Colab
from google.colab import files

# Load the dataset
df = pd.read_csv('/content/Football_Championship_2023_Shots.csv')

# Basic cleaning and preprocessing
# Drop rows with missing values in any of the critical columns
df.dropna(subset=['Pressure', 'Score', 'Foot', 'Position', 'Action'], inplace=True)

# Standardize categories for consistency
df['Action'] = df['Action'].str.lower()
df['Score'] = df['Score'].str.lower()
df['Foot'] = df['Foot'].str.lower()
df['Pressure'] = df['Pressure'].map({'y': 1, 'n': 0})  # Converting 'Pressure' into a binary indicator
df['Position'] = df['Position'].str.capitalize()

# Convert 'Score' to a binary indicator (1 for Score, 0 for Miss or other outcomes)
df['Score'] = np.where(df['Score'] == 'score', 1, 0)

# Drop unnecessary or redundant columns if needed
# For example, 'Unnamed: 0' seems to be an index column
df.drop(columns=['Unnamed: 0'], inplace=True)

# Save the cleaned and preprocessed DataFrame to a new CSV file
output_path = 'cleaned_Football_Championship_2023_Shots.csv'
df.to_csv(output_path, index=False)

# Download the file to your local machine
files.download(output_path)

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import classification_report

# Load dataset
df = pd.read_csv('/content/cleaned_Football_Championship_2023_Shots.csv')

def preprocess_and_engineer_features(df):
    df['Preferred_Side'] = df.apply(lambda row: is_preferable_side(row['stand_y'], row['Foot']), axis=1)
    label_encoder = LabelEncoder()
    df['Position_Value'] = label_encoder.fit_transform(df['Position'])
    df['Foot_Value'] = label_encoder.fit_transform(df['Foot'])
    df['Pressure_Value'] = df['Pressure'].apply(lambda x: 1 if x == 'y' else 0)
    goal_x, goal_y = 145, 44
    df['Shot_Angle'] = np.degrees(np.arctan2(goal_y - df['stand_y'], goal_x - df['stand_x']))
    return df

def is_preferable_side(y, foot):
    return int((y < 44 and foot == 'right') or (y > 44 and foot == 'left') or foot == 'hand')

df = preprocess_and_engineer_features(df)

features = ['Pressure_Value', 'Preferred_Side', 'Position_Value', 'Foot_Value', 'Shot_Angle', 'Shot_Distance']
X = StandardScaler().fit_transform(df[features])
y = df['Score']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

# Predict xP_adv for the entire dataset and make it cumulative for each player
df['xP_adv_shot'] = model.predict_proba(X)[:, 1]
df['xP_adv'] = df.groupby('PlayerName')['xP_adv_shot'].cumsum()

def find_similar_points(df, index, space_threshold=2):
    query = df.iloc[index]
    similar_area = df[
        (df['stand_x'] > (query['stand_x'] - space_threshold)) &
        (df['stand_x'] < (query['stand_x'] + space_threshold)) &
        (df['stand_y'] > (query['stand_y'] - space_threshold)) &
        (df['stand_y'] < (query['stand_y'] + space_threshold))
    ]
    return similar_area

df['xPoints'] = df.apply(lambda row: get_mean_score(find_similar_points(df, row.name)), axis=1)

def get_mean_score(neighbours):
    if neighbours.empty:
        return 0
    return neighbours['Score'].mean()

# Aggregate player stats, including the cumulative xP_adv
player_stats = df.groupby('PlayerName').agg({'Action': 'count', 'Score': 'sum', 'xP_adv': 'max', 'xPoints': 'sum'}).rename(columns={'Action': 'Shots'}).reset_index()
player_stats['Difference'] = player_stats['Score'] - player_stats['xPoints']

# Round all float columns to two decimal places
float_cols = player_stats.select_dtypes(include=['float']).columns
player_stats[float_cols] = player_stats[float_cols].round(2)

player_stats_sorted = player_stats.sort_values(by='Difference', ascending=False)

player_stats_sorted.to_csv('Player_Stats_Sorted_by_Difference_with_xPoints.csv', index=False)
print("Sorted player stats with xPoints exported.")

# For environments that support direct downloads, adjust as necessary
from google.colab import files
files.download('Player_Stats_Sorted_by_Difference_with_xPoints.csv')

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import classification_report

# Load dataset
df = pd.read_csv('/content/cleaned_Football_Championship_2023_Shots.csv')

def preprocess_and_engineer_features(df):
    df['Preferred_Side'] = df.apply(lambda row: is_preferable_side(row['stand_y'], row['Foot']), axis=1)
    label_encoder = LabelEncoder()
    df['Position_Value'] = label_encoder.fit_transform(df['Position'])
    df['Foot_Value'] = label_encoder.fit_transform(df['Foot'])
    df['Pressure_Value'] = df['Pressure'].apply(lambda x: 1 if x == 'y' else 0)
    goal_x, goal_y = 145, 44
    df['Shot_Angle'] = np.degrees(np.arctan2(goal_y - df['stand_y'], goal_x - df['stand_x']))

    # Additional columns
    df['Success_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 1)
    df['Failed_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 0)
    df['Scored_Right'] = (df['Foot'] == 'right') & (df['Score'] == 1)
    df['Scored_Left'] = (df['Foot'] == 'left') & (df['Score'] == 1)
    df['Scored_Hand'] = (df['Foot'] == 'hand') & (df['Score'] == 1)

    return df

def is_preferable_side(y, foot):
    return int((y < 44 and foot == 'right') or (y > 44 and foot == 'left') or foot == 'hand')

df = preprocess_and_engineer_features(df)

features = ['Pressure_Value', 'Preferred_Side', 'Position_Value', 'Foot_Value', 'Shot_Angle', 'Shot_Distance']
X = StandardScaler().fit_transform(df[features])
y = df['Score']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

# Predict xP_adv for the entire dataset and make it cumulative for each player
df['xP_adv_shot'] = model.predict_proba(X)[:, 1]
df['xP_adv'] = df.groupby('PlayerName')['xP_adv_shot'].cumsum()

def find_similar_points(df, index, space_threshold=2):
    query = df.iloc[index]
    similar_area = df[
        (df['stand_x'] > (query['stand_x'] - space_threshold)) &
        (df['stand_x'] < (query['stand_x'] + space_threshold)) &
        (df['stand_y'] > (query['stand_y'] - space_threshold)) &
        (df['stand_y'] < (query['stand_y'] + space_threshold))
    ]
    return similar_area

def get_mean_score(neighbours):
    if neighbours.empty:
        return 0
    return neighbours['Score'].mean()

df['xPoints'] = df.apply(lambda row: get_mean_score(find_similar_points(df, row.name)), axis=1)

# Merge with player stats from the second script
player_stats = df.groupby('PlayerName').agg({
    'Score': ['sum', 'count'],
    'xP_adv_shot': 'sum',
    'Success_Under_Pressure': 'sum',
    'Failed_Under_Pressure': 'sum',
    'Scored_Right': 'sum',
    'Scored_Left': 'sum',
    'Scored_Hand': 'sum',
    'Shot_Distance': 'mean'
}).reset_index()

# Column headers as specified
player_stats.columns = [
    'PlayerName',
    'Scores',
    'Shots',
    'xP_adv_shot_sum',
    'Success_Under_Pressure',
    'Failed_Under_Pressure',
    'Scored_Right',
    'Scored_Left',
    'Scored_Hand',
    'Shot_Distance_mean'
]

# Additional calculations
player_stats['Success_Under_Pressure_Percentage'] = (player_stats['Success_Under_Pressure'] / (player_stats['Success_Under_Pressure'] + player_stats['Failed_Under_Pressure']) * 100).fillna(0)
player_stats['xPoints'] = player_stats['xP_adv_shot_sum'] / player_stats['Shots']
player_stats['Difference'] = player_stats['Scores'] - player_stats['xPoints']

# Sort by 'Difference' in ascending order
player_stats_sorted = player_stats.sort_values(by='Difference', ascending=False)

# Round all float columns to two decimal places
float_cols = player_stats_sorted.select_dtypes(include=['float']).columns
player_stats_sorted[float_cols] = player_stats_sorted[float_cols].round(2)

# Exporting Sorted Player Stats
output_filename = 'Player_Stats_Sorted_by_Difference_with_xPoints.csv'
player_stats_sorted.to_csv(output_filename, index=False)
print("Sorted player stats with xPoints exported.")

# For environments that support direct downloads, adjust as necessary
from google.colab import files
files.download('Player_Stats_Sorted_by_Difference_with_xPoints.csv')

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import classification_report

# Load dataset
df = pd.read_csv('/content/cleaned_Football_Championship_2023_Shots.csv')

def preprocess_and_engineer_features(df):
    df['Preferred_Side'] = df.apply(lambda row: is_preferable_side(row['stand_y'], row['Foot']), axis=1)
    label_encoder = LabelEncoder()
    df['Position_Value'] = label_encoder.fit_transform(df['Position'])
    df['Foot_Value'] = label_encoder.fit_transform(df['Foot'])
    df['Pressure_Value'] = df['Pressure'].apply(lambda x: 1 if x == 'y' else 0)
    goal_x, goal_y = 145, 44
    df['Shot_Angle'] = np.degrees(np.arctan2(goal_y - df['stand_y'], goal_x - df['stand_x']))

    # Additional columns
    df['Success_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 1)
    df['Failed_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 0)
    df['Scored_Right'] = (df['Foot'] == 'right') & (df['Score'] == 1)
    df['Scored_Left'] = (df['Foot'] == 'left') & (df['Score'] == 1)
    df['Scored_Hand'] = (df['Foot'] == 'hand') & (df['Score'] == 1)

    return df

def is_preferable_side(y, foot):
    return int((y < 44 and foot == 'right') or (y > 44 and foot == 'left') or foot == 'hand')

df = preprocess_and_engineer_features(df)

features = ['Pressure_Value', 'Preferred_Side', 'Position_Value', 'Foot_Value', 'Shot_Angle', 'Shot_Distance']
X = StandardScaler().fit_transform(df[features])
y = df['Score']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

# Predict xP_adv for the entire dataset and make it cumulative for each player
df['xP_adv_shot'] = model.predict_proba(X)[:, 1]
df['xP_adv'] = df.groupby('PlayerName')['xP_adv_shot'].cumsum()

def find_similar_points(df, index, space_threshold=2):
    query = df.iloc[index]
    similar_area = df[
        (df['stand_x'] > (query['stand_x'] - space_threshold)) &
        (df['stand_x'] < (query['stand_x'] + space_threshold)) &
        (df['stand_y'] > (query['stand_y'] - space_threshold)) &
        (df['stand_y'] < (query['stand_y'] + space_threshold))
    ]
    return similar_area

def get_mean_score(neighbours):
    if neighbours.empty:
        return 0
    return neighbours['Score'].mean()

df['xPoints'] = df.apply(lambda row: get_mean_score(find_similar_points(df, row.name)), axis=1)

# Merge with player stats from the second script
player_stats = df.groupby('PlayerName').agg({
    'Score': ['sum', 'count'],
    'xP_adv_shot': 'sum',
    'Success_Under_Pressure': 'sum',
    'Failed_Under_Pressure': 'sum',
    'Scored_Right': 'sum',
    'Scored_Left': 'sum',
    'Scored_Hand': 'sum',
    'Shot_Distance': 'mean'
}).reset_index()

# Rearrange the columns as specified
player_stats = player_stats[[
    ('PlayerName', ''),
    ('Score', 'sum'),
    ('Score', 'count'),
    ('xP_adv_shot', 'sum'),
    ('Success_Under_Pressure', 'sum'),
    ('Failed_Under_Pressure', 'sum'),
    ('Scored_Right', 'sum'),
    ('Scored_Left', 'sum'),
    ('Scored_Hand', 'sum'),
    ('Shot_Distance', 'mean'),
]]

# Rename the columns
player_stats.columns = [
    'PlayerName',
    'Scores',
    'Shots',
    'xP_adv_shot',
    'Success_Under_Pressure',
    'Failed_Under_Pressure',
    'Scored_Right',
    'Scored_Left',
    'Scored_Hand',
    'Shot_Distance',
]

# Additional calculations
player_stats['Success_Under_Pressure_Percentage'] = (player_stats['Success_Under_Pressure'] / (player_stats['Success_Under_Pressure'] + player_stats['Failed_Under_Pressure']) * 100).fillna(0)

# Correct calculation of xPoints
player_stats['xPoints'] = player_stats.apply(lambda row: get_mean_score(find_similar_points(df, row.name)), axis=1)

player_stats['Difference'] = player_stats['Scores'] - player_stats['xPoints']

# Sort by 'Difference' in ascending order
player_stats_sorted = player_stats.sort_values(by='Difference', ascending=False)

# Round all float columns to two decimal places
float_cols = player_stats_sorted.select_dtypes(include=['float']).columns
player_stats_sorted[float_cols] = player_stats_sorted[float_cols].round(2)

# Exporting Sorted Player Stats
output_filename = 'Player_Stats_Sorted_by_Difference_with_xPoints.csv'
player_stats_sorted.to_csv(output_filename, index=False)
print("Sorted player stats with xPoints exported.")


# For environments that support direct downloads, adjust as necessary
from google.colab import files
files.download('Player_Stats_Sorted_by_Difference_with_xPoints.csv')

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import classification_report

# Load dataset
df = pd.read_csv('/content/cleaned_Football_Championship_2023_Shots.csv')

def preprocess_and_engineer_features(df):
    df['Preferred_Side'] = df.apply(lambda row: is_preferable_side(row['stand_y'], row['Foot']), axis=1)
    label_encoder = LabelEncoder()
    df['Position_Value'] = label_encoder.fit_transform(df['Position'])
    df['Foot_Value'] = label_encoder.fit_transform(df['Foot'])
    df['Pressure_Value'] = df['Pressure'].apply(lambda x: 1 if x == 'y' else 0)
    goal_x, goal_y = 145, 44
    df['Shot_Angle'] = np.degrees(np.arctan2(goal_y - df['stand_y'], goal_x - df['stand_x']))

    # Additional columns
    df['Success_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 1)
    df['Failed_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 0)
    df['Scored_Right'] = (df['Foot'] == 'right') & (df['Score'] == 1)
    df['Scored_Left'] = (df['Foot'] == 'left') & (df['Score'] == 1)
    df['Scored_Hand'] = (df['Foot'] == 'hand') & (df['Score'] == 1)

    return df

def is_preferable_side(y, foot):
    return int((y < 44 and foot == 'right') or (y > 44 and foot == 'left') or foot == 'hand')

df = preprocess_and_engineer_features(df)

features = ['Pressure_Value', 'Preferred_Side', 'Position_Value', 'Foot_Value', 'Shot_Angle', 'Shot_Distance']
X = StandardScaler().fit_transform(df[features])
y = df['Score']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

# Predict xP_adv for the entire dataset and make it cumulative for each player
df['xP_adv_shot'] = model.predict_proba(X)[:, 1]
df['xP_adv'] = df.groupby('PlayerName')['xP_adv_shot'].cumsum()

def find_similar_points(df, index, space_threshold=2):
    query = df.iloc[index]
    similar_area = df[
        (df['stand_x'] > (query['stand_x'] - space_threshold)) &
        (df['stand_x'] < (query['stand_x'] + space_threshold)) &
        (df['stand_y'] > (query['stand_y'] - space_threshold)) &
        (df['stand_y'] < (query['stand_y'] + space_threshold))
    ]
    return similar_area

def get_mean_score(neighbours):
    if neighbours.empty:
        return 0
    return neighbours['Score'].mean()

df['xPoints'] = df.apply(lambda row: get_mean_score(find_similar_points(df, row.name)), axis=1)

# Merge with player stats from the second script
player_stats = df.groupby('PlayerName').agg({
    'Score': ['sum', 'count'],
    'xP_adv_shot': 'sum',
    'Success_Under_Pressure': 'sum',
    'Failed_Under_Pressure': 'sum',
    'Scored_Right': 'sum',
    'Scored_Left': 'sum',
    'Scored_Hand': 'sum',
    'Shot_Distance': 'mean'
}).reset_index()

# Rearrange the columns as specified
player_stats = player_stats[[
    ('PlayerName', ''),
    ('Score', 'sum'),
    ('Score', 'count'),
    ('xP_adv_shot', 'sum'),
    ('Success_Under_Pressure', 'sum'),
    ('Failed_Under_Pressure', 'sum'),
    ('Scored_Right', 'sum'),
    ('Scored_Left', 'sum'),
    ('Scored_Hand', 'sum'),
    ('Shot_Distance', 'mean'),
]]

# Rename the columns
player_stats.columns = [
    'PlayerName',
    'Scores',
    'Shots',
    'xP_adv_shot',
    'Success_Under_Pressure',
    'Failed_Under_Pressure',
    'Scored_Right',
    'Scored_Left',
    'Scored_Hand',
    'Shot_Distance',
]

# Additional calculations
player_stats['Success_Under_Pressure_Percentage'] = (player_stats['Success_Under_Pressure'] / (player_stats['Success_Under_Pressure'] + player_stats['Failed_Under_Pressure']) * 100).fillna(0)

# Correct calculation of xPoints
player_stats['xPoints'] = player_stats.apply(lambda row: get_mean_score(find_similar_points(df, row.name)), axis=1)

player_stats['Difference'] = player_stats['Scores'] - player_stats['xPoints']

# Sort by 'Difference' in ascending order
player_stats_sorted = player_stats.sort_values(by='Difference', ascending=False)

# Round all float columns to two decimal places
float_cols = player_stats_sorted.select_dtypes(include=['float']).columns
player_stats_sorted[float_cols] = player_stats_sorted[float_cols].round(2)

# Exporting Sorted Player Stats
output_filename = 'Player_Stats_Sorted_by_Difference_with_xPoints.csv'
player_stats_sorted.to_csv(output_filename, index=False)
print("Sorted player stats with xPoints exported.")

# For environments that support direct downloads, adjust as necessary
from google.colab import files
files.download('Player_Stats_Sorted_by_Difference_with_xPoints.csv')

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import classification_report

# Load dataset
df = pd.read_csv('/content/cleaned_Football_Championship_2023_Shots.csv')

def preprocess_and_engineer_features(df):
    df['Preferred_Side'] = df.apply(lambda row: is_preferable_side(row['stand_y'], row['Foot']), axis=1)
    label_encoder = LabelEncoder()
    df['Position_Value'] = label_encoder.fit_transform(df['Position'])
    df['Foot_Value'] = label_encoder.fit_transform(df['Foot'])
    df['Pressure_Value'] = df['Pressure'].apply(lambda x: 1 if x == 'y' else 0)
    goal_x, goal_y = 145, 44
    df['Shot_Angle'] = np.degrees(np.arctan2(goal_y - df['stand_y'], goal_x - df['stand_x']))

    # Additional columns
    df['Success_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 1)
    df['Failed_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 0)
    df['Scored_Right'] = (df['Foot'] == 'right') & (df['Score'] == 1)
    df['Scored_Left'] = (df['Foot'] == 'left') & (df['Score'] == 1)
    df['Scored_Hand'] = (df['Foot'] == 'hand') & (df['Score'] == 1)

    return df

def is_preferable_side(y, foot):
    return int((y < 44 and foot == 'right') or (y > 44 and foot == 'left') or foot == 'hand')

df = preprocess_and_engineer_features(df)

features = ['Pressure_Value', 'Preferred_Side', 'Position_Value', 'Foot_Value', 'Shot_Angle', 'Shot_Distance']
X = StandardScaler().fit_transform(df[features])
y = df['Score']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

# Predict xP_adv for the entire dataset and make it cumulative for each player
df['xP_adv_shot'] = model.predict_proba(X)[:, 1]
df['xP_adv'] = df.groupby('PlayerName')['xP_adv_shot'].cumsum()

def find_similar_points(df, index, space_threshold=2):
    query = df.iloc[index]
    similar_area = df[
        (df['stand_x'] > (query['stand_x'] - space_threshold)) &
        (df['stand_x'] < (query['stand_x'] + space_threshold)) &
        (df['stand_y'] > (query['stand_y'] - space_threshold)) &
        (df['stand_y'] < (query['stand_y'] + space_threshold))
    ]
    return similar_area

def get_mean_score(neighbours):
    if neighbours.empty:
        return 0
    return neighbours['Score'].mean()

df['xPoints'] = df.apply(lambda row: get_mean_score(find_similar_points(df, row.name)), axis=1)

# Aggregate player stats, including the cumulative xP_adv and sum of xPoints
player_stats = df.groupby('PlayerName').agg({
    'Score': ['sum', 'count'],
    'xP_adv_shot': 'sum',
    'xPoints': 'sum',  # Sum of xPoints for each player
    'Success_Under_Pressure': 'sum',
    'Failed_Under_Pressure': 'sum',
    'Scored_Right': 'sum',
    'Scored_Left': 'sum',
    'Scored_Hand': 'sum',
    'Shot_Distance': 'mean'
}).reset_index()

# Rearrange the columns as specified
player_stats = player_stats[[
    ('PlayerName', ''),
    ('Score', 'sum'),
    ('Score', 'count'),
    ('xP_adv_shot', 'sum'),
    ('xPoints', 'sum'),  # Include the sum of xPoints
    ('Success_Under_Pressure', 'sum'),
    ('Failed_Under_Pressure', 'sum'),
    ('Scored_Right', 'sum'),
    ('Scored_Left', 'sum'),
    ('Scored_Hand', 'sum'),
    ('Shot_Distance', 'mean'),
]]

# Rename the columns
player_stats.columns = [
    'PlayerName',
    'Scores',
    'Shots',
    'xP_adv_shot',
    'xPoints',  # Rename the column for sum of xPoints
    'Success_UP',
    'Failed_UP',
    'Scored_Right',
    'Scored_Left',
    'Scored_Hand',
    'Shot_Distance',
]

# Additional calculations
player_stats['Success_UP_Percentage'] = (player_stats['Success_UP'] / (player_stats['Success_UP'] + player_stats['Failed_UP']) * 100).fillna(0)
player_stats['Difference'] = player_stats['Scores'] - player_stats['xPoints']

# Sort by 'Difference' in ascending order
player_stats_sorted = player_stats.sort_values(by='Difference', ascending=False)

# Round all float columns to two decimal places
float_cols = player_stats_sorted.select_dtypes(include=['float']).columns
player_stats_sorted[float_cols] = player_stats_sorted[float_cols].round(2)

# Exporting Sorted Player Stats
output_filename = 'Player_Stats_Sorted_by_Difference_with_xPoints.csv'
player_stats_sorted.to_csv(output_filename, index=False)
print("Sorted player stats with xPoints exported.")

# For environments that support direct downloads, adjust as necessary
from google.colab import files
files.download(output_filename)

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import classification_report

# Load dataset
df = pd.read_csv('/content/cleaned_Football_Championship_2023_Shots.csv')

def preprocess_and_engineer_features(df):
    df['Preferred_Side'] = df.apply(lambda row: is_preferable_side(row['stand_y'], row['Foot']), axis=1)
    label_encoder = LabelEncoder()
    df['Position_Value'] = label_encoder.fit_transform(df['Position'])
    df['Foot_Value'] = label_encoder.fit_transform(df['Foot'])
    df['Pressure_Value'] = df['Pressure'].apply(lambda x: 1 if x == 'y' else 0)
    goal_x, goal_y = 145, 44
    df['Shot_Angle'] = np.degrees(np.arctan2(goal_y - df['stand_y'], goal_x - df['stand_x']))

    # Additional columns
    df['Success_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 1)
    df['Failed_Under_Pressure'] = (df['Pressure'] == 1) & (df['Score'] == 0)
    df['Scored_Right'] = (df['Foot'] == 'right') & (df['Score'] == 1)
    df['Scored_Left'] = (df['Foot'] == 'left') & (df['Score'] == 1)
    df['Scored_Hand'] = (df['Foot'] == 'hand') & (df['Score'] == 1)

    return df

def is_preferable_side(y, foot):
    return int((y < 44 and foot == 'right') or (y > 44 and foot == 'left') or foot == 'hand')

df = preprocess_and_engineer_features(df)

# Features including 'Team_Label'
features = ['Pressure_Value', 'Preferred_Side', 'Position_Value', 'Foot_Value', 'Shot_Angle', 'Shot_Distance']
X = StandardScaler().fit_transform(df[features])
y = df['Score']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

# Predict xP_adv for the entire dataset and make it cumulative for each player
df['xP_adv_shot'] = model.predict_proba(X)[:, 1]
df['xP_adv'] = df.groupby('PlayerName')['xP_adv_shot'].cumsum()

def find_similar_points(df, index, space_threshold=2):
    query = df.iloc[index]
    similar_area = df[
        (df['stand_x'] > (query['stand_x'] - space_threshold)) &
        (df['stand_x'] < (query['stand_x'] + space_threshold)) &
        (df['stand_y'] > (query['stand_y'] - space_threshold)) &
        (df['stand_y'] < (query['stand_y'] + space_threshold))
    ]
    return similar_area

def get_mean_score(neighbours):
    if neighbours.empty:
        return 0
    return neighbours['Score'].mean()

df['xPoints'] = df.apply(lambda row: get_mean_score(find_similar_points(df, row.name)), axis=1)

# Added this line Fechin :)
# Aggregate player stats, including the cumulative xP_adv and sum of xPoints
player_stats = df.groupby(['PlayerName', 'TeamName']).agg({
    'Score': ['sum', 'count'],
    'xP_adv_shot': 'sum',
    'xPoints': 'sum',  # Sum of xPoints for each player
    'Success_Under_Pressure': 'sum',
    'Failed_Under_Pressure': 'sum',
    'Scored_Right': 'sum',
    'Scored_Left': 'sum',
    'Scored_Hand': 'sum',
    'Shot_Distance': 'mean'
}).reset_index()

# Rearrange the columns as specified
player_stats = player_stats[[
    ('PlayerName', ''),
    ('TeamName', ''),  # Include TeamName just after PlayerName
    ('Score', 'sum'),
    ('Score', 'count'),
    ('xP_adv_shot', 'sum'),
    ('xPoints', 'sum'),  # Include the sum of xPoints
    ('Success_Under_Pressure', 'sum'),
    ('Failed_Under_Pressure', 'sum'),
    ('Scored_Right', 'sum'),
    ('Scored_Left', 'sum'),
    ('Scored_Hand', 'sum'),
    ('Shot_Distance', 'mean'),
]]

# Rename the columns
player_stats.columns = [
    'PlayerName',
    'TeamName',  # Rename TeamName column
    'Scores',
    'Shots',
    'xP_adv_shot',
    'xPoints',  # Rename the column for sum of xPoints
    'Success_UP',
    'Failed_UP',
    'Scored_Right',
    'Scored_Left',
    'Scored_Hand',
    'Shot_Distance',
]

# Additional calculations
player_stats['Success_UP_Percentage'] = (player_stats['Success_UP'] / (player_stats['Success_UP'] + player_stats['Failed_UP']) * 100).fillna(0)
player_stats['Difference'] = player_stats['Scores'] - player_stats['xPoints']

# Sort by 'Difference' in ascending order
player_stats_sorted = player_stats.sort_values(by='Difference', ascending=False)

# Round all float columns to two decimal places
float_cols = player_stats_sorted.select_dtypes(include=['float']).columns
player_stats_sorted[float_cols] = player_stats_sorted[float_cols].round(2)

# Exporting Sorted Player Stats
output_filename = 'Player_Stats_Sorted_by_Difference_with_xPoints.csv'
player_stats_sorted.to_csv(output_filename, index=False)
print("Sorted player stats with xPoints exported.")

# For environments that support direct downloads, adjust as necessary
from google.colab import files
files.download(output_filename)

import pandas as pd
from google.colab import files

# Load CSV file
df = pd.read_csv('/content/Player_Stats_Sorted_by_Difference_with_xPoints.csv')

# Convert DataFrame to JSON
json_data = df.to_json(orient='records')

# Save JSON to a file
output_file_path = '/content/DS_Player_Stats_Sorted_by_Difference_with_xPoints.json'
with open(output_file_path, 'w') as file:
    file.write(json_data)

# Download JSON file
files.download(output_file_path)