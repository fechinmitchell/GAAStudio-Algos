# -*- coding: utf-8 -*-
"""XP_GAA_Player.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KFEAejnDNaTpX_dwvXtJhQRE9e-Nja93
"""

import pandas as pd
from sklearn.impute import SimpleImputer
from sklearn.linear_model import LogisticRegression
from google.colab import files

# Load the dataset directly
file_path = 'Football_Championship_2023_Shots.xlsx'
df = pd.read_excel(file_path)

# Preprocess data
df['Is_Score'] = np.where((df['Score'] == 'Score'), 1, 0)
df['Pressure_Value'] = df['Pressure'].map({'y': 1, 'n': 0})
df['Position_Value'] = df['Position'].map({'goalkeeper': 0, 'back': 1, 'midfielder': 2, 'forward': 3})
df['Foot_Value'] = df['Foot'].map({'right': 0, 'left': 1, 'hand': 2})

# Impute missing values
imputer = SimpleImputer(strategy='median')
X_cols = ['Pressure_Value', 'Position_Value', 'Foot_Value', 'Shot_Distance']
X = imputer.fit_transform(df[X_cols])
y = df['Is_Score']

# Train the logistic regression model
model = LogisticRegression(max_iter=1000)
model.fit(X, y)

# Predict 'xP_adv'
df['xP_adv'] = model.predict_proba(X)[:, 1]

# Aggregate statistics by player
player_stats = df.groupby('PlayerName').agg(
    Shots=('PlayerName', 'count'),
    Score=('Is_Score', 'sum'),
    xP_adv=('xP_adv', 'sum')
).reset_index()

# Directly assign xP_adv to xPoints as per current requirement
player_stats['xPoints'] = player_stats['xP_adv']

# Calculate 'Difference' as 'Score' - 'xPoints'
player_stats['Difference'] = player_stats['Score'] - player_stats['xPoints']

# Sort by 'Difference' in descending order
player_stats_sorted = player_stats.sort_values(by='Difference', ascending=False)

# Reorder and rename columns as necessary to match the desired outcome
player_stats_final = player_stats_sorted[['PlayerName', 'Shots', 'Score', 'xP_adv', 'xPoints', 'Difference']]

# Export the sorted data to a CSV file
output_filename = 'Player_Stats_Sorted_by_Difference.csv'
player_stats_final.to_csv(output_filename, index=False)

# Download the file
files.download(output_filename)

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report
from sklearn.model_selection import train_test_split
from sklearn import metrics
from matplotlib.patches import Arc, Rectangle, ConnectionPatch
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
from matplotlib.patches import Arc

# Set display options
pd.set_option('display.max_rows', None)

# Load the dataset directly
file_path = 'Football_Championship_2023_Shots.xlsx'
df = pd.read_excel(file_path)

# Ensure there are both scores and misses in the dataset
if 'Score' not in df.columns:
    df['Score'] = np.where(df['Action'] == 'point', 1, 0)

# Verify presence of both classes
assert df['Score'].nunique() == 2, "Dataset must contain both classes (score and miss)."

# Define and apply preferable side function
def is_preferable_side(y, foot):
    side = 'center'
    if y < 44:
        side = 'left'
    elif y > 44:
        side = 'right'
    preferable_side = int((side == 'left' and foot == 'right') or (side == 'right' and foot == 'left') or foot == 'hand')
    return preferable_side

df['Preferred_Side'] = df.apply(lambda row: is_preferable_side(row['stand_y'], row['Foot']), axis=1)

# Map categorical variables to numerical values
df['Pressure_Value'] = df['Pressure'].map({'y': 1, 'n': 0})
df['Position_Value'] = df['Position'].map({'goalkeeper': 0, 'back': 1, 'midfielder': 2, 'forward': 3})
df['Foot_Value'] = df['Foot'].map({'right': 0, 'left': 1, 'hand': 2})

# Calculate shot angle
def calculate_shot_angle(row):
    goal_x, goal_y = 145, 44  # Assuming constant goal coordinates
    delta_x = goal_x - row['stand_x']
    delta_y = abs(goal_y - row['stand_y'])
    angle_radians = np.arctan(delta_y / delta_x)
    return np.degrees(angle_radians)

df['Shot_Angle'] = df.apply(calculate_shot_angle, axis=1)

# Placed ball calculation
df['Placed_Ball'] = np.where(df['Action'].isin(['point', 'goal']), 1, 0)

# Prepare data for logistic regression model
features = ['Preferred_Side', 'Pressure_Value', 'Position_Value', 'Foot_Value', 'Shot_Angle', 'Shot_Distance', 'Placed_Ball']
X = df[features].fillna(0)  # Fill NA values with 0, adjust as necessary
y = df['Score']

# Fit logistic regression model
model = LogisticRegression(max_iter=1000)
model.fit(X, y)
df['xP_adv'] = model.predict_proba(X)[:, 1]

# Calculate xPoints
space_threshold = 2

def find_similar_points(x, y, df):
    similar_area = df[((df['stand_x'] - x).abs() < space_threshold) & ((df['stand_y'] - y).abs() < space_threshold)]
    return similar_area

def get_mean_score(similar_area):
    return similar_area['Score'].mean()

df['xPoints'] = df.apply(lambda row: get_mean_score(find_similar_points(row['stand_x'], row['stand_y'], df)), axis=1)

# Aggregate and analyze results
player_stats = df.groupby('PlayerName').agg(
    Shots=('PlayerName', 'count'),
    Score=('Score', 'sum'),
    xP_adv=('xP_adv', 'sum'),
    xPoints=('xPoints', 'mean')
).reset_index()

player_stats['Difference'] = player_stats['Score'] - player_stats['xP_adv']
player_stats_sorted = player_stats.sort_values(by='Difference', ascending=False)

# Display the top 10 player stats
print(player_stats_sorted[['PlayerName', 'Shots', 'Score', 'xP_adv', 'xPoints', 'Difference']].head(10))

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, r2_score
import seaborn as sns
from matplotlib.patches import Arc, Rectangle, ConnectionPatch
from sklearn import metrics

# If running in Google Colab, use the following lines to upload the dataset file
# from google.colab import files
# uploaded = files.upload()

# Set display options
pd.set_option('display.max_rows', None)

# Load the dataset directly
file_path = 'Football_Championship_2023_Shots.xlsx'
df = pd.read_excel(file_path)

# Data preprocessing steps
# Remove goals
df = df[~df['Action'].str.contains('goal', case=False)]

# Add Value to scores
df['Score'] = np.where(df['Outcome'] == 'Score', 1, 0)

# Define a function for determining the preferable side
def is_preferable_side(y, foot):
    side = 'center'
    if y < 44:
        side = 'left'
    elif y > 44:
        side = 'right'

    if ((side == 'left' and foot == 'right') or
        (side == 'right' and foot == 'left') or
        (foot == 'hand')):
        return 1
    else:
        return 0

# Apply the preferable side function
df['Preferred_Side'] = df.apply(lambda row: is_preferable_side(row['stand_y'], row['Foot']), axis=1)

# Map categorical variables to integers
df['Pressure_Value'] = df['Pressure'].map({'y': 1, 'n': 0})
df['Position_Value'] = df['Position'].map({'goalkeeper': 0, 'back': 1, 'midfielder': 2, 'forward': 3})
df['Foot_Value'] = df['Foot'].map({'right': 0, 'left': 1, 'hand': 2})

# Calculate the Shot Angle
def calculate_shot_angle(row):
    goal_x, goal_y = 145, 44  # Goal position
    delta_x = goal_x - row['stand_x']
    delta_y = goal_y - row['stand_y']
    angle_radians = np.arctan2(delta_y, delta_x)
    return np.degrees(angle_radians)

df['Shot_Angle'] = df.apply(calculate_shot_angle, axis=1)

# Placed Balls
df['Placed_Ball'] = np.where(df['Action'].isin(['point', 'blocked', 'post', 'short', 'wide']), 0, 1)

# Logistic Regression to find xPoint
X_cols = ['Preferred_Side', 'Pressure_Value', 'Position_Value', 'Foot_Value', 'Shot_Angle', 'Shot_Distance', 'Placed_Ball']
X = df[X_cols]
y = df['Score']
model = LogisticRegression(max_iter=1000)  # Increase max_iter if needed
model.fit(X, y)
y_pred = model.predict_proba(X)[:, 1]
df['xP_adv'] = y_pred

# Compare xPoints with Actual Points per Player
player_stats = df.groupby('PlayerName').agg({'Action':'count', 'Score':'sum', 'xP_adv':'sum'}).reset_index()
player_stats.rename(columns={'Action':'Shots', 'xP_adv':'Expected Points'}, inplace=True)

# Calculate the difference between actual and expected points
player_stats['Difference'] = player_stats['Score'] - player_stats['Expected Points']

# Sort by difference
player_stats_sorted = player_stats.sort_values(by='Difference', ascending=False)

# Reorder and rename columns as necessary to match the desired outcome
player_stats_final = player_stats_sorted[['PlayerName', 'Shots', 'Score', 'Expected Points', 'Difference']]

# Export the sorted data to a CSV file
output_filename = 'Player_Stats_Sorted_by_Difference.csv'
player_stats_final.to_csv(output_filename, index=False)

# If running in Google Colab, use the following line to download the CSV file
# files.download(output_filename)